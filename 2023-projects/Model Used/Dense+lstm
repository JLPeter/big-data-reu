# -*- coding: utf-8 -*-
"""Copy of Dense_LSTM_Model_Ice_bed_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1le3XKvkT8cxhiSSRE0B4bTNR28suWIWr

#Ice Bed Height Prediction Using Dense-LSTM Model  

This notebook used the Dense and LSTM based deep learning model to predict ice bed height using 5 variables ['surf_vx', 'surf_vy', 'surf_elv', 'surf_dhdt', 'surf_SMB']. Here both the old data and new interpolated data are used for prediction. The Dense-LSTM model is trained using training data and tested on testing data.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import mean_squared_error
import h5py
import xarray as xr
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import GradientBoostingRegressor
from sklearn import tree
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import accuracy_score
from sklearn.metrics import roc_auc_score

from google.colab import drive
drive.mount('/content/drive')

def rmspe(y_true, y_pred):
    return np.sqrt(np.nanmean(np.square(((y_true - y_pred) / y_true))))*100

def rmspe_1(y_true, y_pred):
    return np.sqrt(np.nanmean(np.square(y_true - y_pred) / y_true))*100

"""## Old Data"""

df_train1=pd.read_csv('/content/drive/MyDrive/Dataset/train.csv')
df_train=pd.read_csv('/content/drive/MyDrive/Kriging/track_bed_training_interpolated_kriging2.csv')
df_test=pd.read_csv('/content/drive/MyDrive/Dataset/test.csv')
df_pred=pd.read_csv('/content/drive/MyDrive/Dataset/y_test.csv')
data_1201=pd.read_csv('/content/drive/MyDrive/Dataset/df_1201.csv')

df_train1

df_train = df_train.drop_duplicates(["surf_x", "surf_y", "track_bed_target"])
df_train

df_test

data_1201

df_test_only_reading=df_test.drop(['track_bed_test_x','track_bed_test_y','surf_x', 'surf_y'],axis=1)
#df_train_only_reading=df_train.drop(['track_bed_x','track_bed_y','surf_x', 'surf_y'],axis=1)
df_train_only_reading=df_train.drop(['Unnamed: 0', 'surf_x', 'surf_y'],axis=1)


# Make order match
#df_train_only_reading = df.reindex(columns=new_column_order)
#column_name_mapping = {'surf_vx_arr': 'NewName1', 'OldName2': 'NewName2', 'OldName3': 'NewName3'}


column_name_mapping = {'surf_vx_arr': 'surf_vx', 'surf_vy_arr': 'surf_vy', 'surf_elv_arr': 'surf_elv', 'surf_dhdt_arr':'surf_dhdt', 'surf_SMB_arr':'surf_SMB', 'track_bed_target':'track_bed_target' }
# Rename the columns using the mapping
df_train_only_reading = df_train_only_reading.rename(columns=column_name_mapping)
new_column_order = ['surf_vx', 'surf_vy', 'surf_elv', 'surf_dhdt', 'surf_SMB', 'track_bed_target']
df_train_only_reading = df_train_only_reading[new_column_order]


test_data_1201=data_1201.drop(['Unnamed: 0','surf_x', 'surf_y'],axis=1)
test_data_1201_ordered = test_data_1201[['surf_vx', 'surf_vy', 'surf_elv', 'surf_dhdt', 'surf_SMB']]

df_test_only_reading.keys(), df_train_only_reading.keys(), test_data_1201_ordered.keys()

x1_train=df_train_only_reading.iloc[:,:-1]
y1_train=df_train_only_reading.iloc[:,-1:]
X_test_given=df_test_only_reading.iloc[:,:]
Y_test_given=df_pred.iloc[:,:]

import numpy as np
import matplotlib.pyplot as plt

labels = ['surf_vx', 'surf_vy', 'surf_elv', 'surf_dhdt', 'surf_SMB']

#MultipleBoxplot
plt.figure(figsize=(20,6))

plt.subplot(1, 3, 1)
plt.ylim([-700, 2700])
plt.boxplot(x1_train, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : Training Data')


plt.subplot(1, 3, 2)
plt.ylim([-700, 2700])
plt.boxplot(X_test_given, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : Testing Data')


plt.subplot(1, 3, 3)
plt.ylim([-700, 2700])
plt.boxplot(test_data_1201_ordered, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : 1201x1201 Grid Data')

plt.tight_layout()
plt.show()

x1_train.shape, X_test_given.shape, test_data_1201_ordered.shape

all_X = np.concatenate((x1_train, X_test_given, test_data_1201_ordered), axis=0)
all_X.shape

y1_train.shape, Y_test_given.shape

all_Y = np.concatenate((y1_train, Y_test_given), axis=0)
all_Y.shape

# Check range of data

print(data_train_Y.min())
print(data_train_Y.max())
print("\n")
print(data_test_Y.min())
print(data_test_Y.max())

from sklearn.preprocessing import MinMaxScaler

scaler_X = MinMaxScaler(feature_range=(0, 1))
scaler_Y = MinMaxScaler(feature_range=(0, 1))

all_X_nor = scaler_X.fit_transform(all_X)
all_Y_nor = scaler_Y.fit_transform(all_Y)

all_X_nor.shape, all_Y_nor.shape

#seperate the dependent and independent variable for train, test, and 1201 dataset
data_train_X = all_X_nor[0:396734, :]
data_train_Y = all_Y_nor[0:396734, :]
data_test_X = all_X_nor[396734:632706, :]
data_test_Y = all_Y_nor[396734:, :]
data_1201_X = all_X_nor[632706:, :]

print(data_train_X.min())
print(data_train_X.max())
print("\n")
print(data_test_X.min())
print(data_test_X.max())

data_test_X.shape

data_test_Y.shape

#pd.DataFrame.from_records(data_train_X).boxplot(), pd.DataFrame.from_records(data_test_X).boxplot(), pd.DataFrame.from_records(data_1201_X).boxplot()

import numpy as np
import matplotlib.pyplot as plt

labels = ['surf_vx', 'surf_vy', 'surf_elv', 'surf_dhdt', 'surf_SMB']

#MultipleBoxplot
plt.figure(figsize=(20,6))

plt.subplot(1, 3, 1)
plt.ylim([-0.1, 1.1])
plt.boxplot(data_train_X, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : Training Data')


plt.subplot(1, 3, 2)
plt.ylim([-0.1, 1.1])
plt.boxplot(data_test_X, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : Testing Data')


plt.subplot(1, 3, 3)
plt.ylim([-0.1, 1.1])
plt.boxplot(data_1201_X, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : 1201x1201 Grid Data')


plt.tight_layout()
plt.show()

data_train_X_lstm = data_train_X.reshape(data_train_X.shape[0], 1, data_train_X.shape[1])
data_train_X_lstm.shape

data_test_X_lstm = data_test_X.reshape(data_test_X.shape[0], 1, data_test_X.shape[1])
data_test_X_lstm.shape

data_1201_X.shape

data_1201_X_lstm = data_1201_X.reshape(data_1201_X.shape[0], 1, data_1201_X.shape[1])
data_1201_X_lstm.shape

"""### Training model using old data"""

import keras,os
from keras.models import Sequential
from keras.models import Model
from keras.layers import Dense, Conv2D, MaxPool2D , Flatten, Dropout, AveragePooling2D, LSTM, Activation, ConvLSTM2D, TimeDistributed, Input, Reshape
from keras.layers import UpSampling1D, Conv2DTranspose, UpSampling2D, BatchNormalization
from tensorflow.keras import callbacks
import numpy as np

def get_model(input_dims):
  input_batch = Input(shape = input_dims)

  conv_model = TimeDistributed(Dense(128, activation="sigmoid"), name='ConvL1')(input_batch)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dense(128, activation="sigmoid"), name='ConvL2' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dropout(0.5))(conv_model)
  conv_model = TimeDistributed(Dense(64, activation="sigmoid"), name='ConvL3' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dense(64, activation="sigmoid"), name='ConvL4' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dropout(0.5))(conv_model)
  conv_model = TimeDistributed(Dense(32, activation="sigmoid"), name='ConvL5' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dense(32, activation="sigmoid"), name='ConvL6' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dropout(0.5))(conv_model)

  lstm_network = LSTM(64, return_sequences=True)(conv_model)
  lstm_network = keras.layers.LSTM(32, return_sequences=False)(lstm_network)
  lstm_network = Dropout(0.5)(lstm_network)
  lstm_network = keras.layers.Dense(32, activation='sigmoid', name='Dense1')(lstm_network)
  lstm_network = keras.layers.Dense(1, activation='linear', name='Dense2')(lstm_network)

  encoder = Model(inputs=input_batch, outputs=lstm_network, name='encoder')

  return encoder



model = get_model(data_train_X_lstm.shape[1:])
model.summary()
model.compile(optimizer='adam', loss='mse')
model.fit(data_train_X_lstm, y=data_train_Y, epochs=200, batch_size=5000, verbose=1, validation_split =0.3, shuffle=True,
          callbacks=[callbacks.EarlyStopping(monitor='val_loss', patience=100,verbose=2, mode='auto')])

"""####Prediction of the track bed on training data"""

y_pred_train = model.predict(data_train_X_lstm)

y_pred_train.shape, data_train_Y.shape

train_Predict_full_range = scaler_Y.inverse_transform(y_pred_train)
data_train_Y_full_range = scaler_Y.inverse_transform(data_train_Y)



from sklearn.metrics import mean_absolute_error, r2_score, mean_absolute_percentage_error

print('RMSE:',np.sqrt(mean_squared_error(data_train_Y_full_range, train_Predict_full_range)))
print('RMSE Percentage:',rmspe(data_train_Y_full_range, train_Predict_full_range))
print('RMSE Percentage-1:',rmspe_1(data_train_Y_full_range, train_Predict_full_range))
print('Mean Absolute Error:', mean_absolute_error(data_train_Y_full_range, train_Predict_full_range))
print('Mean Absolute Percentage Error:', mean_absolute_percentage_error(data_train_Y_full_range, train_Predict_full_range))
print('R^2 Score:', r2_score(data_train_Y_full_range, train_Predict_full_range))

import matplotlib.pyplot as plt

plt.subplots(figsize=(15, 5))

plt.plot(data_train_Y_full_range, color='red', label="Ground Truth") # Y_test_given,y_pred_test
plt.plot(train_Predict_full_range, color='blue', label="Prediction")
plt.ylabel("Ice Bed Height")
plt.xlabel("Data Elements")
plt.legend(loc="upper left")
plt.show()

"""####Prediction of track bed on test data"""

data_test_X_lstm.shape

y_predict_test = model.predict(data_test_X_lstm)

data_test_Y.shape, y_predict_test.shape

data_test_X_lstm.shape

test_Predict_full_range = scaler_Y.inverse_transform(y_predict_test)
data_test_Y_full_range = scaler_Y.inverse_transform(data_test_Y)

from sklearn.metrics import mean_absolute_error, r2_score, mean_absolute_percentage_error

print('RMSE:',np.sqrt(mean_squared_error(data_test_Y_full_range, test_Predict_full_range)))
print('RMSE Percentage:',rmspe(data_test_Y_full_range, test_Predict_full_range))
print('RMSE Percentage-1:',rmspe_1(data_test_Y_full_range, test_Predict_full_range))
print('Mean Absolute Error:', mean_absolute_error(data_test_Y_full_range, test_Predict_full_range))
print('Mean Absolute Percentage Error:', mean_absolute_percentage_error(data_test_Y_full_range, test_Predict_full_range))
print('R^2 Score:', r2_score(data_test_Y_full_range, test_Predict_full_range))

import matplotlib.pyplot as plt

plt.subplots(figsize=(15, 5))

plt.plot(data_test_Y_full_range, color='red', label="Ground Truth") # Y_test_given,y_pred_test
plt.plot(test_Predict_full_range, color='blue', label="Prediction")
plt.ylabel("Ice Bed Height")
plt.xlabel("Data Elements")
plt.legend(loc="upper left")
plt.show()

"""#### Prediction of ice bed height on 1201x1201 grid data"""

data_1201_X_lstm.shape

y_Predict_1201 = model.predict(data_1201_X_lstm)

y_Predict_1201.shape

y_Predict_1201_full = scaler_Y.inverse_transform(y_Predict_1201)

y_Predict_1201_full.shape

y_Predict_1201_full_flatten=y_Predict_1201_full.flatten()



prediction_on_1201_2D=y_Predict_1201_full_flatten.reshape(1201,1201)
prediction_on_1201_2D.shape

new_filename_2 = '/content/drive/MyDrive/Kriging/kriging_predicted_output_5_epoch.h5'

with h5py.File(new_filename_2, 'w') as hf:
    hf.create_dataset("track bed prediction",  data=prediction_on_1201_2D)

import matplotlib.pyplot as plt
plt.imshow(np.transpose(prediction_on_1201_2D), cmap="seismic")
#plt.imshow(a.squeeze(), cmap="seismic", interpolation="nearest") # new interpolated data
plt.title('Track Bed Prediction')
plt.xlabel('x-axis')
plt.ylabel('y-axis')
plt.colorbar(label="Color-bar", orientation="horizontal")

"""## New Interpolation Data"""

n_training_data = pd.read_csv('/content/drive/MyDrive/Ice-bed_dataset/new_interpolated_track_bed_training.csv')
n_testing_data = pd.read_csv('/content/drive/MyDrive/Ice-bed_dataset/new_interpotaled_track_bed_testing.csv')
n_df_pred = pd.read_csv('/content/drive/MyDrive/Ice-bed_dataset/y_test.csv')
n_data_1201 = pd.read_csv('/content/drive/MyDrive/Ice-bed_dataset/df_1201.csv')
n_test_data_1201 = n_data_1201.drop(['Unnamed: 0','surf_x', 'surf_y'],axis=1)

n_training_data

n_testing_data

n_training_data = n_training_data.drop(['Unnamed: 0','surf_x', 'surf_y'],axis=1)
n_testing_data = n_testing_data.drop(['Unnamed: 0','surf_x', 'surf_y'],axis=1)

n_training_data.shape, n_testing_data.shape, n_test_data_1201.shape

n_training_data.keys(), n_testing_data.keys(), n_test_data_1201.keys()

n_x1_train = n_training_data.iloc[:,1:]
n_y1_train = n_training_data.iloc[:,0:1]
n_X_test_given = n_testing_data.iloc[:,:]
n_Y_test_given = n_df_pred.iloc[:,:]

#n_x1_train.boxplot(), n_X_test_given.boxplot(), n_test_data_1201.boxplot()

import numpy as np
import matplotlib.pyplot as plt

labels = ['surf_vx', 'surf_vy', 'surf_dhdt', 'surf_SMB', 'surf_elv']

#MultipleBoxplot
plt.figure(figsize=(20,6))

plt.subplot(1, 3, 1)
plt.ylim([-700, 2700])
plt.boxplot(n_x1_train, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : New Training Data')


plt.subplot(1, 3, 2)
plt.ylim([-700, 2700])
plt.boxplot(n_X_test_given, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : New Testing Data')


plt.subplot(1, 3, 3)
plt.ylim([-700, 2700])
plt.boxplot(n_test_data_1201, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : 1201x1201 Grid Data')

plt.tight_layout()
plt.show()

n_x1_train.shape, n_X_test_given.shape, n_test_data_1201.shape

n_all_X = np.concatenate((n_x1_train, n_X_test_given, n_test_data_1201), axis=0)
n_all_X.shape

n_y1_train.shape, n_Y_test_given.shape

n_all_Y = np.concatenate((n_y1_train, n_Y_test_given), axis=0)
n_all_Y.shape

from sklearn.preprocessing import MinMaxScaler

scaler_X = MinMaxScaler(feature_range=(0, 1))
scaler_Y = MinMaxScaler(feature_range=(0, 1))

n_all_X_nor = scaler_X.fit_transform(n_all_X)
n_all_Y_nor = scaler_Y.fit_transform(n_all_Y)

n_all_X_nor.shape, n_all_Y_nor.shape

#seperate the dependent and independent variable for train, test, and 1201 dataset
n_data_train_X = n_all_X_nor[0:396734, :]
n_data_train_Y = n_all_Y_nor[0:396734, :]
n_data_test_X = n_all_X_nor[396734:632706, :]
n_data_test_Y = n_all_Y_nor[396734:, :]
n_data_1201_X = n_all_X_nor[632706:, :]

#pd.DataFrame.from_records(n_data_train_X).boxplot(), pd.DataFrame.from_records(n_data_test_X).boxplot(), pd.DataFrame.from_records(n_data_1201_X).boxplot()

import numpy as np
import matplotlib.pyplot as plt

labels = ['surf_vx', 'surf_vy', 'surf_dhdt', 'surf_SMB', 'surf_elv']

#MultipleBoxplot
plt.figure(figsize=(20,6))

plt.subplot(1, 3, 1)
plt.ylim([-0.1, 1.1])
plt.boxplot(n_data_train_X, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : New Training Data')


plt.subplot(1, 3, 2)
plt.ylim([-0.1, 1.1])
plt.boxplot(n_data_test_X, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : New Testing Data')


plt.subplot(1, 3, 3)
plt.ylim([-0.1, 1.1])
plt.boxplot(n_data_1201_X, vert=True, patch_artist=True, labels=labels)
plt.ylabel('observed value')
plt.title('Box Plot : 1201x1201 Grid Data')


plt.tight_layout()
plt.show()

n_data_train_X_lstm = n_data_train_X.reshape(n_data_train_X.shape[0], 1, n_data_train_X.shape[1])
n_data_train_X_lstm.shape

n_data_test_X_lstm = n_data_test_X.reshape(n_data_test_X.shape[0], 1, n_data_test_X.shape[1])
n_data_test_X_lstm.shape

n_data_1201_X_lstm = n_data_1201_X.reshape(n_data_1201_X.shape[0], 1, n_data_1201_X.shape[1])
n_data_1201_X_lstm.shape

"""### Training model using new interpolation data"""

import keras,os
from keras.models import Sequential
from keras.models import Model
from keras.layers import Dense, Conv2D, MaxPool2D , Flatten, Dropout, AveragePooling2D, LSTM, Activation, ConvLSTM2D, TimeDistributed, Input, Reshape
from keras.layers import UpSampling1D, Conv2DTranspose, UpSampling2D, BatchNormalization
from tensorflow.keras import callbacks
import numpy as np

def get_model(input_dims):
  input_batch = Input(shape = input_dims)

  conv_model = TimeDistributed(Dense(128, activation="sigmoid"), name='ConvL1')(input_batch)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dense(128, activation="sigmoid"), name='ConvL2' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dropout(0.5))(conv_model)
  conv_model = TimeDistributed(Dense(64, activation="sigmoid"), name='ConvL3' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dense(64, activation="sigmoid"), name='ConvL4' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dropout(0.5))(conv_model)
  conv_model = TimeDistributed(Dense(32, activation="sigmoid"), name='ConvL5' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dense(32, activation="sigmoid"), name='ConvL6' )(conv_model)
  conv_model = TimeDistributed(BatchNormalization())(conv_model)
  conv_model = TimeDistributed(Dropout(0.5))(conv_model)

  lstm_network = LSTM(64, return_sequences=True)(conv_model)
  lstm_network = keras.layers.LSTM(32, return_sequences=False)(lstm_network)
  lstm_network = Dropout(0.5)(lstm_network)
  lstm_network = keras.layers.Dense(32, activation='sigmoid', name='Dense1')(lstm_network)
  lstm_network = keras.layers.Dense(1, activation='linear', name='Dense2')(lstm_network)

  encoder = Model(inputs=input_batch, outputs=lstm_network, name='encoder')

  return encoder

n_model = get_model(n_data_train_X_lstm.shape[1:])
n_model.summary()
n_model.compile(optimizer='adam', loss='mse')
n_model.fit(n_data_train_X_lstm, y=n_data_train_Y, epochs=200, batch_size=5000, verbose=1, validation_split =0.3, shuffle=True,
          callbacks=[callbacks.EarlyStopping(monitor='val_loss', patience=100,verbose=2, mode='auto')])

#n_model.fit(data_train_X_lstm, y=n_data_train_Y, epochs=200, batch_size=5000, verbose=1, validation_split =0.3, shuffle=True,
#          callbacks=[callbacks.EarlyStopping(monitor='val_loss', patience=100,verbose=2, mode='auto')])

"""####Prediction of the track bed on new training data"""

n_y_pred_train = n_model.predict(n_data_train_X_lstm)

n_y_pred_train.shape, n_data_train_Y.shape

n_train_Predict_full_range = scaler_Y.inverse_transform(n_y_pred_train)
n_data_train_Y_full_range = scaler_Y.inverse_transform(n_data_train_Y)

from sklearn.metrics import mean_absolute_error, r2_score, mean_absolute_percentage_error

print('RMSE:',np.sqrt(mean_squared_error(n_data_train_Y_full_range, n_train_Predict_full_range)))
print('RMSE Percentage:',rmspe(n_data_train_Y_full_range, n_train_Predict_full_range))
print('RMSE Percentage-1:',rmspe_1(n_data_train_Y_full_range, n_train_Predict_full_range))
print('Mean Absolute Error:', mean_absolute_error(n_data_train_Y_full_range, n_train_Predict_full_range))
print('Mean Absolute Percentage Error:', mean_absolute_percentage_error(n_data_train_Y_full_range, n_train_Predict_full_range))
print('R^2 Score:', r2_score(n_data_train_Y_full_range, n_train_Predict_full_range))

import matplotlib.pyplot as plt

plt.subplots(figsize=(15, 5))

plt.plot(n_data_train_Y_full_range, color='red', label="Ground Truth") # Y_test_given,y_pred_test
plt.plot(n_train_Predict_full_range, color='blue', label="Prediction")
plt.ylabel("Ice Bed Height")
plt.xlabel("Data Elements")
plt.legend(loc="upper left")
plt.show()

"""####Prediction of track bed on new test data"""

n_y_predict_test = n_model.predict(n_data_test_X_lstm)

n_data_test_Y.shape, n_y_predict_test.shape

n_test_Predict_full_range = scaler_Y.inverse_transform(n_y_predict_test)
n_data_test_Y_full_range = scaler_Y.inverse_transform(n_data_test_Y)

from sklearn.metrics import mean_absolute_error, r2_score, mean_absolute_percentage_error

print('RMSE:',np.sqrt(mean_squared_error(n_data_test_Y_full_range, n_test_Predict_full_range)))
print('RMSE Percentage:',rmspe(n_data_test_Y_full_range, n_test_Predict_full_range))
print('RMSE Percentage-1:',rmspe_1(n_data_test_Y_full_range, n_test_Predict_full_range))
print('Mean Absolute Error:', mean_absolute_error(n_data_test_Y_full_range, n_test_Predict_full_range))
print('Mean Absolute Percentage Error:', mean_absolute_percentage_error(n_data_test_Y_full_range, n_test_Predict_full_range))
print('R^2 Score:', r2_score(n_data_test_Y_full_range, n_test_Predict_full_range))

import matplotlib.pyplot as plt

plt.subplots(figsize=(15, 5))

plt.plot(n_data_test_Y_full_range, color='red', label="Ground Truth") # Y_test_given,y_pred_test
plt.plot(n_test_Predict_full_range, color='blue', label="Prediction")
plt.ylabel("Ice Bed Height")
plt.xlabel("Data Elements")
plt.legend(loc="upper left")
plt.show()

"""#### Prediction of ice bed height on 1201x1201 grid data"""

n_y_Predict_1201 = n_model.predict(n_data_1201_X_lstm)

n_y_Predict_1201.shape

n_y_Predict_1201_full = scaler_Y.inverse_transform(n_y_Predict_1201)

n_y_Predict_1201_full_flatten=n_y_Predict_1201_full.flatten()

n_prediction_on_1201_2D=n_y_Predict_1201_full_flatten.reshape(1201,1201)
n_prediction_on_1201_2D.shape

new_filename_2 = '/content/drive/MyDrive/Ice-bed_dataset/ice_bed_prediction_1201_Dense_LSTM_new.h5'

with h5py.File(new_filename_2, 'w') as hf:
    hf.create_dataset("track bed prediction",  data=n_prediction_on_1201_2D)

import matplotlib.pyplot as plt
plt.imshow(np.transpose(n_prediction_on_1201_2D), cmap="seismic")
#plt.imshow(a.squeeze(), cmap="seismic", interpolation="nearest") # new interpolated data
plt.title('Track Bed Prediction')
plt.xlabel('x-axis')
plt.ylabel('y-axis')
plt.colorbar(label="Color-bar", orientation="horizontal")
